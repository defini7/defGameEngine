#define DGE_APPLICATION
#include "defGameEngine.hpp"

enum ТипСтороны
{
		СТОРОНА_НЕОПРЕДЕЛЕНО,
		СТОРОНА_ЛЕВО,
		СТОРОНА_ПРАВО,
		СТОРОНА_ВЕРХ,
		СТОРОНА_НИЗ
};

constexpr int РАЗМЕР_ПЛИТКИ = 32;

struct Блок
{
		virtual void Нарисовать(def::GameEngine* движок, const def::vi2d& позиция) const
		{
				if (движок)
						движок->DrawPartialSprite(позиция * РАЗМЕР_ПЛИТКИ, файловаяПозиция, { РАЗМЕР_ПЛИТКИ, РАЗМЕР_ПЛИТКИ }, с_Графика);
		}

		virtual bool Двинуть(ТипСтороны сторонаКасания)
		{
				return false;
		}

		def::vi2d файловаяПозиция;

		static def::Sprite* с_Графика;
};

def::Sprite* Блок::с_Графика = nullptr;

struct Блок_Стоп : Блок
{
		Блок_Стоп()
		{
				файловаяПозиция = { 0, 0 };
		}
};

struct Блок_ЛюбоеНаправление : Блок
{
		Блок_ЛюбоеНаправление()
		{
				файловаяПозиция = { РАЗМЕР_ПЛИТКИ, 0 };
		}

		bool Двинуть(ТипСтороны сторонаКасания) override
		{
				return сторонаКасания != СТОРОНА_НЕОПРЕДЕЛЕНО;
		}
};

struct Блок_Горизонтальный : Блок
{
		Блок_Горизонтальный()
		{
				файловаяПозиция = { 2 * РАЗМЕР_ПЛИТКИ, 0 };
		}

		bool Двинуть(ТипСтороны сторонаКасания) override
		{
				return сторонаКасания == СТОРОНА_ЛЕВО || сторонаКасания == СТОРОНА_ПРАВО;
		}
};

struct Блок_Вертикальный : Блок
{
		Блок_Вертикальный()
		{
				файловаяПозиция = { 3 * РАЗМЕР_ПЛИТКИ, 0 };
		}

		bool Двинуть(ТипСтороны сторонаКасания) override
		{
				return сторонаКасания == СТОРОНА_ВЕРХ || сторонаКасания == СТОРОНА_НИЗ;
		}
};

struct Блок_Счётчик : Блок
{
		Блок_Счётчик(int допустимыеХоды = 0)
		{
				оставшиесяХоды = допустимыеХоды;
				файловаяПозиция = { 4 * РАЗМЕР_ПЛИТКИ, 0 };
		}

		bool Двинуть(ТипСтороны сторонаКасания) override
		{
				if (сторонаКасания != СТОРОНА_НЕОПРЕДЕЛЕНО && оставшиесяХоды > 0)
				{
						оставшиесяХоды--;
						return true;
				}

				return false;
		}

		void Нарисовать(def::GameEngine* движок, const def::vi2d& позиция) const override
		{
				Блок::Нарисовать(движок, позиция);
				движок->DrawString(позиция * РАЗМЕР_ПЛИТКИ + РАЗМЕР_ПЛИТКИ / 8, std::to_string(оставшиесяХоды), def::WHITE);
		}

		int оставшиесяХоды;
};

struct Блок_Препятствие : Блок
{
		Блок_Препятствие()
		{
				файловаяПозиция = { 5 * РАЗМЕР_ПЛИТКИ, 0 };
		}
};

class СкользящиеБлоки : public def::GameEngine
{
public:
		СкользящиеБлоки()
		{
				SetTitle("Sliding Blocks");
		}

		virtual ~СкользящиеБлоки()
		{
				delete Блок::с_Графика;

				for (auto блок : карта)
						delete блок;
		}

		std::vector<Блок*> карта;
		def::vi2d размерКарты;

		def::vi2d позицияИгрока = { 1, 1 };

protected:
		void ДвинутьБлоки(ТипСтороны сторонаКасания)
		{
				std::function<bool(int, int, ТипСтороны)> двинуть = [&](int икс, int игрек, ТипСтороны сторонаКасания) -> bool
						{
								size_t и = игрек * размерКарты.x + икс;

								if (карта[и])
								{
										if (карта[и]->Двинуть(сторонаКасания))
										{
												switch (сторонаКасания)
												{
												case СТОРОНА_ПРАВО: икс--;   break;
												case СТОРОНА_ЛЕВО:	икс++;   break;
												case СТОРОНА_НИЗ:	игрек--; break;
												case СТОРОНА_ВЕРХ:  игрек++; break;
												}

												if (двинуть(икс, игрек, сторонаКасания))
												{
														карта[игрек * размерКарты.x + икс] = карта[и];
														карта[и] = nullptr;

														return true;
												}
										}

										return false;
								}

								return true;
				};

				if (сторонаКасания != СТОРОНА_НЕОПРЕДЕЛЕНО)
				{
						def::vi2d возможнаяПозиция = позицияИгрока;

						switch (сторонаКасания)
						{
						case СТОРОНА_ПРАВО: возможнаяПозиция.x--; break;
						case СТОРОНА_ЛЕВО:	возможнаяПозиция.x++; break;
						case СТОРОНА_НИЗ:   возможнаяПозиция.y--; break;
						case СТОРОНА_ВЕРХ:  возможнаяПозиция.y++; break;
						}

						if (двинуть(возможнаяПозиция.x, возможнаяПозиция.y, сторонаКасания))
								позицияИгрока = возможнаяПозиция;
				}
		}

		bool OnUserCreate() override
		{
				Блок::с_Графика = new def::Sprite("Assets/blocks.png");

				std::string строка;
				строка += "################";
				строка += "#........5.....#";
				строка += "#.+........4...#";
				строка += "#....@@@@@.....#";
				строка += "#...@..........#";
				строка += "#...@.......+..#";
				строка += "#...@..9.......#";
				строка += "#...@..........#";
				строка += "#........-..|..#";
				строка += "#...+..........#";
				строка += "#........@.....#";
				строка += "#.|.........7..#";
				строка += "#....@...-.....#";
				строка += "#..............#";
				строка += "#........-.....#";
				строка += "################";

				размерКарты = GetScreenSize() / РАЗМЕР_ПЛИТКИ;
				карта.resize(размерКарты.x * размерКарты.y);

				def::vi2d позиция;
				for (; позиция.y < размерКарты.y; позиция.y++)
				{
						for (; позиция.x < размерКарты.x; позиция.x++)
						{
								size_t и = позиция.y * размерКарты.x + позиция.x;

								switch (строка[и])
								{
								case '@': карта[и] = new Блок_Стоп();	          break;
								case '+': карта[и] = new Блок_ЛюбоеНаправление(); break;
								case '-': карта[и] = new Блок_Вертикальный();     break;
								case '|': карта[и] = new Блок_Горизонтальный();   break;
								case '#': карта[и] = new Блок_Препятствие();      break;
								default:
								{
										if (isdigit(строка[и]))
												карта[и] = new Блок_Счётчик(строка[и] - '0');
								}

								}
						}

						позиция.x = 0;
				}

				return true;
		}

		bool OnUserUpdate(float дельтаВремя) override
		{
				ТипСтороны сторонаКасания = СТОРОНА_НЕОПРЕДЕЛЕНО;

				if (GetKey(def::Key::LEFT).pressed)	 сторонаКасания = СТОРОНА_ПРАВО;
				if (GetKey(def::Key::RIGHT).pressed) сторонаКасания = СТОРОНА_ЛЕВО;
				if (GetKey(def::Key::UP).pressed)	 сторонаКасания = СТОРОНА_НИЗ;
				if (GetKey(def::Key::DOWN).pressed)  сторонаКасания = СТОРОНА_ВЕРХ;

				ДвинутьБлоки(сторонаКасания);

				Clear(def::BLACK);

				SetPixelMode(def::Pixel::Mode::MASK);

				for (int игрек = 0; игрек < размерКарты.y; игрек++)
						for (int икс = 0; икс < размерКарты.x; икс++)
						{
								Блок* блок = карта[игрек * размерКарты.x + икс];

								if (блок)
										блок->Нарисовать(this, { икс, игрек });
						}

				SetPixelMode(def::Pixel::Mode::DEFAULT);

				FillRectangle(позицияИгрока * РАЗМЕР_ПЛИТКИ, { РАЗМЕР_ПЛИТКИ, РАЗМЕР_ПЛИТКИ }, def::WHITE);

				return true;
		}
};

int main()
{
		СкользящиеБлоки игра;

		if (игра.Construct(512, 512, 2, 2))
				игра.Run();

		return 0;
}
